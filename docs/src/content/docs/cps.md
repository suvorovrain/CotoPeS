---
title: CPS
description: A reference page in my new Starlight docs site.
---

Для чего это вообще надо? <br/>
Почему мы это учим? <br/>
Зачем проводить допуск на знание CPS? <br/>
Как не запутаться и ней уйти на комсу? <br/>

Про это всё наша методичка.

Для начала рассмотрим хвостые функции и какую они роль играют.

## Хвостовые функции

Рассмотрим довольно простую функцию, которая считает сумму элементов массива

```ocaml
(* int list -> int *)
let rec sum xs =
  match xs with
  | [] -> 0
  | h :: tl -> h + sum tl
```

###### В чем проблема такой функции? <br/>

Проблема в том, что `h + sum tl` **порождает каждый раз новый фрейм на стеке** для того, чтобы обработать повторный вызов `sum tl`. <br/>
Так как нам нужно посчитать `h + sum tl` мы обязаны оставить старый фрейм целым с переменной `h` и создать новый фрейм для подсчета `sum tl` <br/>
Это **заставляет нас все время возвращаться назад** после получения результата.

###### Хвостовая рекурсия

Рассмотрим немного видоизменную функцию, в которую мы добавим **аккумулятор**:

```ocaml
(* int list -> int *)
let rec sum_tail xs acc =
  match xs with
  | [] -> acc
  | h :: tl -> sum_tail tl (acc + h)
```

<!-- Последнее действие? Придумать что-то внятное -->

Отличие этой фукциии от предыдущий в том, что мы смогли добиться _*хвостовой рекурсии (tail recursion).*_ <br/>
Называтеся это так, потому наш рекурсивный вызов `sum_tail` является _*последним действием нашей функции*_ <br/>
Так как вызов рекурсивной функции является последним, что выполняется в текущем вызове функции - нам нет нужды возвращаться назад!
А значит и хранить текущий фрейм нам тоже не нужно -- мы можем беспощадно его удалить со стека.

###### Оптимизация хвостовой рекурсии

Благодаря хвостовой рекурсии мы можем применить больше не хранить старые фреймы и сразу исполнять следующий рекурсивный вызов, тем самым
не заполняя стек. <br/>
Если раньше при вызове функции `sum` на списке из 10млн элеметов мы падали с ошибкой Stack Overflow, то теперь мы можем эффективно это считать и не потреблять лишнюю память

Рассмотрим наглядное применение `sum` и `sum_tail` на массиве [1; 2; 3; 4]

```ocaml
(* sum (1 :: 2 :: 3 :: 4 :: [])
   1 + sum (2 :: 3 :: 4 :: [])
   1 + 2 + sum (3 :: 4 :: [])
   1 + 2 + 3 + sum (4 :: [])
   1 + 2 + 3 + 4 + sum ([])
   1 + 2 + 3 + 4 + 0 // Конец фазы 1
   1 + 2 + 3 + 4
   1 + 2 + 7
   1 + 9
   10
*)
```

Это было довольно трудоемко, не так? Более того, в конце 1 фазы мы имеем в памяти 5 стековых фрейвов! Каждый из них хранит лишь одно число и ждет ожидания вычисления функции `sum tl`, что очень затратно и излишне. <br/>
`sum_tail` лишен этого недостатка и при использовании этой функции у нас не создаются новые лишние стек фреймы.

```ocaml
(* sum_tail (1 :: 2 :: 3 :: 4 :: []) 0
   sum_tail (2 :: 3 :: 4 :: []) 1
   sum_tail (3 :: 4 :: []) 3
   sum_tail (4 :: []) 6
   sum_tail ([]) 10
   10
*)
```

## Что же такое CPS?

---
title: CPS
description: A reference page in my new Starlight docs site.
---

Для чего это вообще надо? <br/>
Почему мы это учим? <br/>
Зачем проводить допуск на знание CPS? <br/>
Как не запутаться и ней уйти на комсу? <br/>

Про это всё наша методичка.

Для начала рассмотрим хвостые функции и какую они роль играют.

## Хвостовые функции

Рассмотрим довольно простую функцию, которая считает сумму элементов массива

```ocaml
(* int list -> int *)
let rec sum xs =
  match xs with
  | [] -> 0
  | h :: tl -> h + sum tl
```

### В чем проблема такой функции? <br/>

Проблема в том, что `h + sum tl` **порождает каждый раз новый фрейм на стеке** для того, чтобы обработать повторный вызов `sum tl`. <br/>
Так как нам нужно посчитать `h + sum tl` мы обязаны оставить старый фрейм целым с переменной `h` и создать новый фрейм для подсчета `sum tl` <br/>
Это **заставляет нас все время возвращаться назад** после получения результата.

### Хвостовая рекурсия

Рассмотрим немного видоизменную функцию, в которую мы добавим **аккумулятор**:

```ocaml
(* int list -> int *)
let rec sum_tail xs acc =
  match xs with
  | [] -> acc
  | h :: tl -> sum_tail tl (acc + h)
```

<!-- Последнее действие? Придумать что-то внятное -->

Отличие этой фукциии от предыдущий в том, что мы смогли добиться _*хвостовой рекурсии (tail recursion).*_ <br/>
Называтеся это так, потому наш рекурсивный вызов `sum_tail` является _*последним действием нашей функции*_ <br/>
Так как вызов рекурсивной функции является последним, что выполняется в текущем вызове функции - нам нет нужды возвращаться назад!
А значит и хранить текущий фрейм нам тоже не нужно -- мы можем беспощадно его удалить со стека.

### Оптимизация хвостовой рекурсии

Благодаря хвостовой рекурсии мы можем применить больше не хранить старые фреймы и сразу исполнять следующий рекурсивный вызов, тем самым
не заполняя стек. <br/>
Если раньше при вызове функции `sum` на списке из 10млн элеметов мы падали с ошибкой Stack Overflow, то теперь мы можем эффективно это считать и не потреблять лишнюю память

Рассмотрим наглядное применение `sum` и `sum_tail` на массиве [1; 2; 3; 4]

```ocaml
(* sum (1 :: 2 :: 3 :: 4 :: [])
   1 + sum (2 :: 3 :: 4 :: [])
   1 + 2 + sum (3 :: 4 :: [])
   1 + 2 + 3 + sum (4 :: [])
   1 + 2 + 3 + 4 + sum ([])
   1 + 2 + 3 + 4 + 0 // Конец фазы 1
   1 + 2 + 3 + 4
   1 + 2 + 7
   1 + 9
   10
*)
```

Это было довольно трудоемко, не так? Более того, в конце 1 фазы мы имеем в памяти 5 стековых фрейвов! Каждый из них хранит лишь одно число и ждет ожидания вычисления функции `sum tl`, что очень затратно и излишне. <br/>
`sum_tail` лишен этого недостатка и при использовании этой функции у нас не создаются новые лишние стек фреймы.

```ocaml
(* sum_tail (1 :: 2 :: 3 :: 4 :: []) 0
   sum_tail (2 :: 3 :: 4 :: []) 1
   sum_tail (3 :: 4 :: []) 3
   sum_tail (4 :: []) 6
   sum_tail ([]) 10
   10
*)
```

## Что же такое CPS?

Если хвостовые функции настолько крутые -- можно ли все крутые рекурсивные функции сделать хвостовыми? <br/>
Хорошая новость: да! <br/>
Плохая новость: не всегда это можно сделать просто

Для этого нам на помощь приходит **Continutaion Passing Style (CPS преобразование)**

### CPS преобразование

:::note[Продолжение (англ. continuation)]
То, что должна сделать функция после вычисления ответа. Обычно реализуется
дополнительным аргументом k, который вызывается от ответа
:::

```ocaml
let sum a b = a + b ⇝ let sumk a b k = k (a + b)
```

:::note[СPS (continuation passing style) преобразование]
Преобразование функций в их аналоги, принимающие продолжения
:::

Особенность CPS преобразования в том, что это позволяет перевести нашу рекурсивную функцию в функции с хвостовой рекурсией! <br/>
Причем -- всегда. Поэтому предупреждения от Какаду:
:::danger
Если CPS не дает хвостовых вызовов -- скорее всего что-то пошло нет так
:::

## Примеры CPS преобразования

Рассмотрим несколько примеров CPS преобразований.

### Factorial

Классический пример, с которого начинается наше путешствествие -- факториал.

```ocaml
(* int -> int *)
let rec fact x = if x = 1 then 1 else x * fact (x - 1)
```

Заметили в чем проблема? ~~Помимо существования отрицательных чисел.~~ <br/>
То, что мы уже видели с функцией `sum`. Для подсчета `fact n` нужно заходить в функцию `fact (n - 1)`, возвращаться и считать `n * fact (n - 1)`. <br/>
Хотим хвостовую рекурсию. Поэтому применим CPS преобразование:

```ocaml
(* int -> (int -> 'a) -> 'a *)
let rec factk x k = if x = 1 then k 1 else factk (x - 1) (fun r -> k (x * r))
```

Что же произошло?

###### Константа

:::tip[CPS от константы]
CPS[1] = k 1
:::
В случае `fact` при `x = 1` нам возвращалось значение `1`. <br/>
Для CPS преобразования достаточно превратить `1` в `k 1`

###### Вызов `fact`

:::tip[Тип функции после CPS преобразования]
Тип функции после CPS строго определен. <br/>
Он имеет тип `Тип до ответа -> (Тип ответа исходной функции -> 'a) -> 'a` <br/>
То есть функция `k` принимает ответ исходной функции, а потом возвращает произвольный ответ типа `'a`.
:::

:::note[Формальная арность функции]
Формульная арность функции `f` это колличество аргументов, которая она принимает. <br/>
:::

:::danger[Формальная арность функции важна]
Так, например, если функция `let f x y = x + y` имеет тип `int -> int -> int`, то CPS преобразование даст функцию `int -> int -> (int -> 'a) -> 'a`. <br/>
Но! Если функция `let f x = fun y -> x + y` имеет тип `int -> (int -> int)`, то CPS преобразование даст функцию типа `int -> ((int -> int) -> 'a) -> 'a` <br/>
Данную разницу необходимо осознать. Формальная арность функции важна!
:::

Заметим, что функция k имеет тип `int -> 'a`. <br/>
Это функция, которая принимает ответ нашей исходной функции. <br/>
Поэтому, когда мы видим вызов `x * fact (x - 1)` стараемся вычислить ответ и передать это в функцию k. <br/>
Получаем: `x * (factk (x - 1) (fun r -> k r))` <br/>
А теперь осознаем, что нам в ответе нужно не `fact (x - 1)`, а `fact (x - 1) * x`, поэтому `x` также засовываем внутрь функции <br/>
Получаем: `factk (x - 1) (fun r -> k (r * x))`

Готово!
